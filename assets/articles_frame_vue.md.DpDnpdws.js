import{_ as i,c as e,o as a,a2 as l}from"./chunks/framework.DrGGipuk.js";const V=JSON.parse('{"title":"十七、VUE","description":"","frontmatter":{},"headers":[],"relativePath":"articles/frame/vue.md","filePath":"articles/frame/vue.md","lastUpdated":1710767618000}'),s={name:"articles/frame/vue.md"},t=l(`<h1 id="十七、vue" tabindex="-1">十七、VUE <a class="header-anchor" href="#十七、vue" aria-label="Permalink to &quot;十七、VUE&quot;">​</a></h1><h2 id="v-model作用" tabindex="-1">v-model作用 <a class="header-anchor" href="#v-model作用" aria-label="Permalink to &quot;v-model作用&quot;">​</a></h2><p>v-model本质上不过是语法糖，可以用 v-model 指令在<strong>表单</strong>及<strong>元素</strong>上创建双向数据绑定。</p><ol><li>它会根据控件类型自动选取正确的方法来更新元素</li><li>它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理</li><li>v-model会忽略所有表单元素的value、checked、selected特性的初始值,而总是将 Vue 实例的数据作为数据来源，因此我们应该通过 JavaScript 在组件的data选项中声明初始值</li></ol><p><strong>扩展：</strong></p><p>v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ol><li>text 和 textarea 元素使用value属性和input事件；</li><li>checkbox 和 radio 使用checked属性和change事件；</li><li>select 字段将value作为 prop 并将change作为事件。</li></ol><h2 id="vue3-0-实现数据双向绑定的方法" tabindex="-1">Vue3.0 实现数据双向绑定的方法 <a class="header-anchor" href="#vue3-0-实现数据双向绑定的方法" aria-label="Permalink to &quot;Vue3.0 实现数据双向绑定的方法&quot;">​</a></h2><p>vue3.0 实现数据双向绑定是通过<strong>Proxy</strong></p><p><strong>Proxy</strong>是 ES6 中新增的一个特性，翻译过来意思是&quot;代理&quot;，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><p>使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。</p><p><strong>扩展：</strong></p><p>使用proxy实现，双向数据绑定，相比2.0的Object.defineProperty ()优势：</p><ol><li>可以劫持整个对象，并返回一个新对象</li><li>有13种劫持操作</li></ol><h2 id="导航守卫" tabindex="-1">导航守卫 <a class="header-anchor" href="#导航守卫" aria-label="Permalink to &quot;导航守卫&quot;">​</a></h2><p>导航守卫主要用来<strong>通过跳转或取消的方式守卫导航</strong>。</p><p>简单的说，导航守卫就是路由跳转过程中的一些钩子函数。路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。</p><p>路由守卫的具体方法：</p><ol><li><p>全局前置守卫</p><p>你可以使用 router.beforeEach 注册一个全局前置守卫：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>每个守卫方法接收三个参数（往后的守卫都大同小异）：</p><ol><li><p>to: Route: 即将要进入的目标 路由对象</p></li><li><p>from: Route: 当前导航正要离开的路由</p></li><li><p>next: Function: 一定要调用该方法将控制权交给下一个守卫，执行效果依赖 next 方法的参数。</p></li></ol></li></ol><h2 id="mvc和mvvm的区别" tabindex="-1">MVC和MVVM的区别 <a class="header-anchor" href="#mvc和mvvm的区别" aria-label="Permalink to &quot;MVC和MVVM的区别&quot;">​</a></h2><p>MVC: MVC是应用最广泛的软件架构之一,一般MVC分为:Model(模型),View(视图),Controller(控制器)。 这主要是基于分层的目的,让彼此的职责分开.View一般用过Controller来和Model进行联系。Controller是Model和View的协调者,View和Model不直接联系。基本都是单向联系。</p><p>MVVM:MVVM是把MVC中的Controller改变成了ViewModel。View的变化会自动更新到ViewModel,ViewModel的变化也会自动同步到View上显示,通过数据来显示视图层。</p><p>MVVM和MVC的区别:</p><ul><li>MVC中Controller演变成MVVM中的ViewModel</li><li>MVVM通过数据来显示视图层而不是节点操作</li><li>MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低,加载速度变慢,影响用户体验</li></ul><h2 id="vue-的初始化过程-new-vue-options-都做了什么" tabindex="-1">Vue 的初始化过程（new Vue(options)）都做了什么？ <a class="header-anchor" href="#vue-的初始化过程-new-vue-options-都做了什么" aria-label="Permalink to &quot;Vue 的初始化过程（new Vue(options)）都做了什么？&quot;">​</a></h2><ul><li>处理组件配置项 <ul><li>初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上</li><li>初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率</li></ul></li><li>初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等</li><li>处理自定义事件</li><li>调用 beforeCreate 钩子函数</li><li>初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行浅层的响应式处理（只处理了对象第一层数据），并代理每个 key 到 vm 实例上</li><li>数据响应式，处理 props、methods、data、computed、watch 等选项</li><li>解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上</li><li>调用 created 钩子函数</li><li>如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount</li><li>接下来则进入挂载阶段</li></ul>`,27),o=[t];function n(r,p,h,d,k,c){return a(),e("div",null,o)}const E=i(s,[["render",n]]);export{V as __pageData,E as default};
