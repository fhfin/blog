import{_ as i,c as s,o as a,a2 as e}from"./chunks/framework.BPg1USI6.js";const E=JSON.parse('{"title":"十七、VUE","description":"","frontmatter":{},"headers":[],"relativePath":"articles/frame/vue.md","filePath":"articles/frame/vue.md","lastUpdated":1709538010000}'),l={name:"articles/frame/vue.md"},t=e(`<h1 id="十七、vue" tabindex="-1">十七、VUE <a class="header-anchor" href="#十七、vue" aria-label="Permalink to &quot;十七、VUE&quot;">​</a></h1><h2 id="v-model作用" tabindex="-1">v-model作用 <a class="header-anchor" href="#v-model作用" aria-label="Permalink to &quot;v-model作用&quot;">​</a></h2><p>v-model本质上不过是语法糖，可以用 v-model 指令在<strong>表单</strong>及<strong>元素</strong>上创建双向数据绑定。</p><ol><li>它会根据控件类型自动选取正确的方法来更新元素</li><li>它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理</li><li>v-model会忽略所有表单元素的value、checked、selected特性的初始值,而总是将 Vue 实例的数据作为数据来源，因此我们应该通过 JavaScript 在组件的data选项中声明初始值</li></ol><p><strong>扩展：</strong></p><p>v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ol><li>text 和 textarea 元素使用value属性和input事件；</li><li>checkbox 和 radio 使用checked属性和change事件；</li><li>select 字段将value作为 prop 并将change作为事件。</li></ol><h2 id="vue3-0-实现数据双向绑定的方法" tabindex="-1">Vue3.0 实现数据双向绑定的方法 <a class="header-anchor" href="#vue3-0-实现数据双向绑定的方法" aria-label="Permalink to &quot;Vue3.0 实现数据双向绑定的方法&quot;">​</a></h2><p>vue3.0 实现数据双向绑定是通过<strong>Proxy</strong></p><p><strong>Proxy</strong>是 ES6 中新增的一个特性，翻译过来意思是&quot;代理&quot;，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><p>使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。</p><p><strong>扩展：</strong></p><p>使用proxy实现，双向数据绑定，相比2.0的Object.defineProperty ()优势：</p><ol><li>可以劫持整个对象，并返回一个新对象</li><li>有13种劫持操作</li></ol><h2 id="导航守卫" tabindex="-1">导航守卫 <a class="header-anchor" href="#导航守卫" aria-label="Permalink to &quot;导航守卫&quot;">​</a></h2><p>导航守卫主要用来<strong>通过跳转或取消的方式守卫导航</strong>。</p><p>简单的说，导航守卫就是路由跳转过程中的一些钩子函数。路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。</p><p>路由守卫的具体方法：</p><ol><li><p>全局前置守卫</p><p>你可以使用 router.beforeEach 注册一个全局前置守卫：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>每个守卫方法接收三个参数（往后的守卫都大同小异）：</p><ol><li><p>to: Route: 即将要进入的目标 路由对象</p></li><li><p>from: Route: 当前导航正要离开的路由</p></li><li><p>next: Function: 一定要调用该方法将控制权交给下一个守卫，执行效果依赖 next 方法的参数。</p></li></ol></li></ol><h2 id="mvc和mvvm的区别" tabindex="-1">MVC和MVVM的区别 <a class="header-anchor" href="#mvc和mvvm的区别" aria-label="Permalink to &quot;MVC和MVVM的区别&quot;">​</a></h2><p>MVC: MVC是应用最广泛的软件架构之一,一般MVC分为:Model(模型),View(视图),Controller(控制器)。 这主要是基于分层的目的,让彼此的职责分开.View一般用过Controller来和Model进行联系。Controller是Model和View的协调者,View和Model不直接联系。基本都是单向联系。</p><p>MVVM:MVVM是把MVC中的Controller改变成了ViewModel。View的变化会自动更新到ViewModel,ViewModel的变化也会自动同步到View上显示,通过数据来显示视图层。</p><p>MVVM和MVC的区别:</p><ul><li>MVC中Controller演变成MVVM中的ViewModel</li><li>MVVM通过数据来显示视图层而不是节点操作</li><li>MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低,加载速度变慢,影响用户体验</li></ul>`,25),o=[t];function n(r,p,h,d,k,c){return a(),s("div",null,o)}const g=i(l,[["render",n]]);export{E as __pageData,g as default};
