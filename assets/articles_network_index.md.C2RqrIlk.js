import{_ as t,c as r,o as a,a2 as o}from"./chunks/framework.BPg1USI6.js";const c=JSON.parse('{"title":"网络传输","description":"","frontmatter":{},"headers":[],"relativePath":"articles/network/index.md","filePath":"articles/network/index.md","lastUpdated":1709538010000}'),i={name:"articles/network/index.md"},l=o('<h1 id="网络传输" tabindex="-1">网络传输 <a class="header-anchor" href="#网络传输" aria-label="Permalink to &quot;网络传输&quot;">​</a></h1><h2 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-label="Permalink to &quot;同源策略&quot;">​</a></h2><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><h2 id="跨域的解决方案" tabindex="-1">跨域的解决方案 <a class="header-anchor" href="#跨域的解决方案" aria-label="Permalink to &quot;跨域的解决方案&quot;">​</a></h2><p>解决方案有jsonp、cors、postMessage、websocket、Node中间件代理(两次跨域)、nginx反向代理、window.name + iframe、location.hash + iframe、document.domain + iframe，CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案，JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。日常工作中，用得比较多的跨域方案是cors和nginx反向代理</p><h2 id="常见的http-status" tabindex="-1">常见的http status <a class="header-anchor" href="#常见的http-status" aria-label="Permalink to &quot;常见的http status&quot;">​</a></h2><p><strong>1XX系列</strong>：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。</p><p><strong>2XX系列</strong>：代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201状态码。</p><p><strong>3XX系列</strong>：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。这系列中最常见的有301、302状态码。</p><p><strong>4XX系列</strong>：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。</p><p><strong>5xx系列</strong>：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码。</p><p><strong>2开头 （请求成功）表示成功处理了请求的状态代码。</strong></p><ul><li>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li><li>201 （已创建） 请求成功并且服务器创建了新的资源。</li><li>202 （已接受） 服务器已接受请求，但尚未处理。</li><li>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</li><li>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>206 （部分内容） 服务器成功处理了部分 GET 请求。</li></ul><p><strong>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</strong></p><ul><li>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</li><li>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li><li>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li><li>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li><li>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</li><li>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li></ul><p><strong>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</strong></p><ul><li>400 （错误请求） 服务器不理解请求的语法。</li><li>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>403 （禁止） 服务器拒绝请求。</li><li>404 （未找到） 服务器找不到请求的网页。</li><li>405 （方法禁用） 禁用请求中指定的方法。</li><li>406 （不接受） 无法使用请求的内容特性响应请求的网页。</li><li>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li><li>408 （请求超时） 服务器等候请求时发生超时。</li><li>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</li><li>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</li><li>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</li><li>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</li><li>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li><li>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</li><li>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。</li><li>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</li><li>417 （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。</li></ul><p><strong>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</strong></p><ul><li>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</li><li>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</li><li>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</li><li>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</li><li>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li><li>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</li></ul><h2 id="http和https" tabindex="-1">http和https <a class="header-anchor" href="#http和https" aria-label="Permalink to &quot;http和https&quot;">​</a></h2><p><strong>1. HTTP和HTTPS的基本概念</strong> HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><p><strong>2.HTTP与HTTPS有什么区别？</strong></p><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证 这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><p><strong>3、https如何保证安全</strong><strong>HTTPS</strong>（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。HTTPS = HTTP + SSL/TLS，如今 SSL 已废弃，所以现在只关注 HTTP + TLS。为了解决 HTTP 协议的问题，HTTPS 引入了<strong>数据加密</strong>和<strong>身份验证机制</strong>。在开始传输数据之前，通过安全可靠的 TLS 协议进行加密，从而保证后续加密传输数据的安全性。</p><p><strong>TLS 协议</strong>：<strong>传输层安全性协议</strong>（Transport Layer Security，<strong>TLS</strong>）及其前身<strong>安全套接层</strong>（Secure Sockets Layer，<strong>SSL</strong>）是一种安全协议，目的是为了保证<strong>网络通信安全</strong>和<strong>数据完整性</strong>。</p><p><strong>受 TLS 协议保护的通信过程</strong>：先对传输的数据进行了加密（使用对称加密算法）。并且对称加密的密钥是为每一个连接唯一生成的（基于 TLS 握手阶段协商的加密算法和共享密钥），然后发送的每条消息都会通过消息验证码（Message authentication code, MAC），来进行消息完整性检查，最后还可以使用公钥对通信双方进行身份验证</p><p><strong>Https的作用</strong> - <strong>内容加密</strong> 建立一个信息安全通道，来保证数据传输的安全； - <strong>身份认证</strong> 确认网站的真实性 - <strong>数据完整性</strong> 防止内容被第三方冒充或者篡改</p><h2 id="ajax" tabindex="-1">ajax <a class="header-anchor" href="#ajax" aria-label="Permalink to &quot;ajax&quot;">​</a></h2><p><strong>为什么要用ajax：</strong></p><p>ajax是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单的说，在不需要重新刷新页面的情况下，Ajax通过异步请求加载后台数据，并在网页上呈现出来。Ajax的目的是提高用户体验，较少网络数据的传输量。</p><h2 id="tcp三次握手" tabindex="-1">tcp三次握手 <a class="header-anchor" href="#tcp三次握手" aria-label="Permalink to &quot;tcp三次握手&quot;">​</a></h2><p>两个目的：</p><ol><li>确保建立可靠连接</li><li>避免资源浪费</li></ol><p>三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立</p><h2 id="https加密解密流程" tabindex="-1">https加密解密流程 <a class="header-anchor" href="#https加密解密流程" aria-label="Permalink to &quot;https加密解密流程&quot;">​</a></h2><p>https加密解密流程分成以下8个步骤：</p><ol><li><strong>客户端发起HTTPS请求</strong> 这个没什么好说的，就是用户在浏览器里输入一个HTTPS网址，然后连接到服务端的443端口。</li><li><strong>服务端的配置</strong> 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥不太理解，可以想象成一把钥匙和一个锁头，只是世界上只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li><li><strong>传送证书</strong> 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</li><li><strong>客户端解析证书</strong> 这部分工作是由客户端的SSL/TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题。如果证书没有问题，那么就生成一个<strong>随机值</strong>。然后用证书（也就是公钥）对这个随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li><li><strong>传送加密信息</strong> 这部分传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li><li><strong>服务端解密信息</strong> 服务端用私钥解密后，得到了客户端传过来的随机值，然后把内容通过该随机值进行对称加密，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li><li><strong>传输加密后的信息</strong> 这部分信息就是服务端用私钥加密后的信息，可以在客户端用随机值解密还原。</li><li><strong>客户端解密信息</strong> 客户端用之前生产的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</li></ol><h2 id="tcp、udp" tabindex="-1">TCP、UDP <a class="header-anchor" href="#tcp、udp" aria-label="Permalink to &quot;TCP、UDP&quot;">​</a></h2><p><strong>TCP(传输控制协议)和UDP（用户数据报协议）</strong> - TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，是专门为了在不可靠的网络中提供一个可靠的端对端字节流而设计的，面向字节流。 - UDP（用户数据报协议）是iso参考模型中一种无连接的传输层协议，提供简单不可靠的非连接传输层服务，面向报文</p><p><strong>区别：</strong></p><ol><li>TCP是面向连接的，可靠性高；UDP是基于非连接的，可靠性低</li><li>由于TCP是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差，同时过程复杂，也使其易于攻击；UDP没有建立连接的过程，因而实时性较强，也稍安全</li><li>在传输相同大小的数据时，TCP首部开销20字节；UDP首部开销8字节，TCP报头比UDP复杂，故实际包含的用户数据较少。TCP在IP协议的基础上添加了序号机制、确认机制、超时重传机制等，保证了传输的可靠性，不会出现丢包或乱序，而UDP有丢包，故TCP开销大，UDP开销较小</li><li>每条TCP连接只能时点到点的；UDP支持一对一、一对多、多对一、多对多的交互通信</li></ol><p><strong>应用场景选择</strong> - 对实时性要求高和高速传输的场合下使用UDP;在可靠性要求低，追求效率的情况下使用UDP; - 需要传输大量数据且对可靠性要求高的情况下使用TCP</p><h2 id="ftp、dns基于什么协议" tabindex="-1">FTP、DNS基于什么协议 <a class="header-anchor" href="#ftp、dns基于什么协议" aria-label="Permalink to &quot;FTP、DNS基于什么协议&quot;">​</a></h2><p>DNS（Domain Name Service 域名服务）协议基于UDP协议</p><p>FTP（File Transfer Prorocol 文件传输协议）基于TCP协议</p><p>DNS和FTP都是应用层协议</p><h2 id="url路径包含什么-uri是什么" tabindex="-1">URL路径包含什么，URI是什么 <a class="header-anchor" href="#url路径包含什么-uri是什么" aria-label="Permalink to &quot;URL路径包含什么，URI是什么&quot;">​</a></h2><p>一个完整的url分为四部分：</p><ol><li>协议 例Http（超文本传输协议）、Https</li><li>域名 例www.baidu.com为网站名字。baidu.com为一级域名，www是服务</li><li>端口 不填写的话默认走的是80端口号</li><li>路径 <a href="http://www.baidu.com/%E8%B7%AF%E5%BE%841/%E8%B7%AF%E5%BE%842%E3%80%82" target="_blank" rel="noreferrer">http://www.baidu.com/路径1/路径2。</a> /表示根目录</li><li>查询参数 <a href="http://www.baidu.com/%E8%B7%AF%E5%BE%841/%E8%B7%AF%E5%BE%842?name=%22man%22%EF%BC%88%E5%8F%AF%E6%9C%89%E5%8F%AF%E6%97%A0%EF%BC%89" target="_blank" rel="noreferrer">http://www.baidu.com/路径1/路径2?name=&quot;man&quot;（可有可无）</a></li></ol><p><strong>URI是什么</strong> URI是一个易于标识互联网资源名称的字符串。该种标识允许用户对网络中（一般指万维网）的资源通过待定的协议进行交互操作。URI的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径。用于在待定的命名空间资源的标识，以补充网址。</p><p><strong>扩展</strong> URL和URN是URI的子集，URI属于URL更高层次的抽象，一种字符串文本标准。</p><h2 id="dns" tabindex="-1">DNS <a class="header-anchor" href="#dns" aria-label="Permalink to &quot;DNS&quot;">​</a></h2><p>DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。</p><h2 id="get和post区别" tabindex="-1">GET和POST区别 <a class="header-anchor" href="#get和post区别" aria-label="Permalink to &quot;GET和POST区别&quot;">​</a></h2><ol><li>get用来获取数据，post用来提交数据</li><li>get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制</li><li>get请求的数据会附加在url之 ，以 &quot; ？ &quot;分割url和传输数据，多个参数用 &quot;&amp;&quot;连接，而post请求会把请求的数据放在http请求体中。</li><li>get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。</li><li>get请求会保存在浏览器历史记录中，还可能保存在web服务器的日志中</li></ol>',62),e=[l];function s(n,p,T,h,g,P){return a(),r("div",null,e)}const u=t(i,[["render",s]]);export{c as __pageData,u as default};
